worker_processes  8;
pid /run/nginx.pid;

events { worker_connections 1024; }

http {
  proxy_cache_path /tmp/nginx levels=1:2 keys_zone=cache_zone:10m inactive=60m max_size=100m;

  client_body_buffer_size 10K;
  client_header_buffer_size 1k;
  client_max_body_size 8m;
  large_client_header_buffers 2 1k;

  client_body_timeout 10;
  client_header_timeout 10;
  keepalive_timeout 12;
  send_timeout 10;

  include       mime.types;
  default_type  application/octet-stream;

  log_format  main_timed  '$remote_addr - $remote_user [$time_local] "$request" '
                          '$status $body_bytes_sent "$http_referer" '
                          '"$http_user_agent" "$http_x_forwarded_for" '
                          '$request_time $upstream_response_time $pipe $upstream_cache_status';

  access_log /dev/stdout main_timed;
  error_log /dev/stderr crit;

  # copies data between one FD and other from within the kernel
  # faster then read() + write()
  sendfile off;

  # send headers in one peace, its better then sending them one by one 
  tcp_nopush on;

  # don't buffer data sent, good for small data bursts in real time
  tcp_nodelay on;

  # reduce the data that needs to be sent over network -- for testing environment
  gzip             on;
  gzip_comp_level  2;
  gzip_min_length  1000;
  gzip_proxied     expired no-cache no-store private auth;
  gzip_types       application/json;

  # allow the server to close connection on non responding client, this will free up memory
  reset_timedout_connection on;

  server {
    listen [::]:80 default_server;
    listen 80 default_server;
    server_name _;

    resolver 8.8.8.8 8.8.4.4 valid=300s;
    resolver_timeout 5s;

    charset utf-8;
    add_header "X-UA-Compatible" "IE=Edge,chrome=1";

    location ~ /(runner|runnerByRace|autocomplete) {
      #  add_header Allow "GET" always;
      if ( $request_method !~ ^(GET)$ ) {
          return 405;
      }
      proxy_set_header X-Forwarded-For $remote_addr;
      proxy_set_header Host $http_host;
      proxy_set_header X-Protocol http;
      proxy_read_timeout 480;
      proxy_connect_timeout 480;
      proxy_cache cache_zone;
      proxy_cache_key "$scheme$request_method$host$request_uri";
      proxy_cache_valid  200 302 304 1m;
      proxy_cache_valid  404      60m;
      add_header X-Cache-Status $upstream_cache_status;
      add_header X-Frame-Options DENY;
      add_header X-Content-Type-Options nosniff;

      proxy_pass http://localhost:5555;
    }

     # redirect bad request to the static page /404.html
      #
      error_page 400 /400.html;
      location  /400.html {
          root /var/lib/nginx/html;
          internal;
      }

      # redirect page not found to the static page /404.html
      #
      error_page 404 /404.html;
      location  /404.html {
          root /var/lib/nginx/html;
          internal;
      }

      # redirect method not allowed to the static page /405.html
      #
      error_page 405 /405.html;
      location  /405.html {
          root /var/lib/nginx/html;
          internal;
      }

      # redirect too many reaquest to the static page /429.html
      #
      error_page 429 /429.html;
      location  /429.html {
          root /var/lib/nginx/html;
          internal;
      }

      # redirect server error to the static page /500.html
      #
      error_page 500 502 503 504 /500.html;
      location  /500.html {
          root /var/lib/nginx/html;
          internal;
      }

    # deny access to . files, for security
        #
    location ~ /\. {
        log_not_found off;
        deny all;
    }
  }
}